// =====================================================
// 0) RESET (careful: deletes everything)
// =====================================================
MATCH (n)
DETACH DELETE n;
// Drop all constraints
CALL apoc.schema.assert({}, {}, true);

// =====================================================
// 1) SCHEMA
// =====================================================
CREATE CONSTRAINT account_id IF NOT EXISTS
FOR (a:Account) REQUIRE a.id IS UNIQUE;

CREATE INDEX stage_acc_level IF NOT EXISTS
FOR (s:Stage) ON (s.accId, s.level);

// =====================================================
// 2) BASE GRAPH: accounts + transfers
//   - 10 accounts
//   - Plus 30 random transfers as background noise
// =====================================================

// Accounts
UNWIND range(1,10) AS i
CREATE (:Account {id: i});

// Random background transfers
MATCH (a:Account)
WITH collect(a) AS nodes, size(collect(a)) AS n
UNWIND range(1,30) AS k
WITH nodes, n, k,
     toInteger(1 + rand()*n) AS i,
     toInteger(1 + rand()*n) AS j
WITH nodes[i-1] AS u, nodes[j-1] AS v, k
WHERE u <> v
CREATE (u)-[:TRANSFER {
  amount: toInteger(1 + rand()*1000),
  ts: datetime("2025-01-01") + duration({days: toInteger(rand()*365)})
}]->(v);

// =====================================================
// 3) BASELINE QUERY (original graph)
// Find targets reachable an Account by an unbounded path
// whose edge amounts are strictly increasing.
// Note: the monotonicity check happens in the WHERE filter.
// =====================================================
MATCH p = (s:Account)-[:TRANSFER*]->(t:Account)
WITH s, p, [r IN relationships(p) | r.amount] AS amts, t
WHERE size(amts) > 0
  AND ALL(i IN range(1, size(amts)-1) WHERE amts[i-1] < amts[i])
RETURN s.id AS source, t.id AS target, length(p) AS hops, amts
ORDER BY hops DESC, target

// =====================================================
// 4) BUILD THE LIFTED GRAPH (StageLift)
// Nodes: (accId, level) where level ∈ incoming amounts ∪ { -1 sentinel }
// Edges: for each base edge u-[:TRANSFER {amount:j}]->v,
//        connect every (u, ℓ) with ℓ < j to (v, j).
// This compiles the inequality into the graph.
// =====================================================

// 4.1 Stage nodes with levels per account (include sentinel -1)
PROFILE
MATCH (v:Account)
OPTIONAL MATCH (:Account)-[e:TRANSFER]->(v)
WITH v, collect(DISTINCT e.amount) AS inAmts
WITH v, [-1] + [amt IN inAmts WHERE amt IS NOT NULL] AS levels
UNWIND levels AS level
MERGE (:Stage {accId: v.id, level: level});

// 4.2 Stage edges that enforce ℓ < j by construction
PROFILE
MATCH (u:Account)-[e:TRANSFER]->(v:Account)
WITH u, v, e, e.amount AS j, e.ts AS ts
MATCH (su:Stage {accId: u.id})
WHERE su.level < j
MERGE (sv:Stage {accId: v.id, level: j})
MERGE (su)-[le:TRANSFER_LIFT {amount: j}]->(sv)
  ON CREATE SET le.ts = ts;

// =====================================================
// 5) LIFTED QUERY (simplified)
// Now the query is plain reachability from (level -1) over TRANSFER_LIFT,
// because the increased guard is baked into the edges.
// =====================================================
MATCH (start:Stage {level: -1})
MATCH p = (start)-[:TRANSFER_LIFT*]->(x:Stage)
RETURN start.accId AS source, x.accId AS target, length(p) AS hops,
       [r IN relationships(p) | r.amount] AS amts
ORDER BY hops DESC, target


// =====================================================
// 6) Sanity check - exact (s,t,amounts)
//     If both counts are 0 → PASS
// =====================================================
CALL {
  // Original graph (include the amount sequence)
  MATCH p = (s:Account)-[:TRANSFER*]->(t:Account)
  WITH s, t, [r IN relationships(p) | r.amount] AS amts
  WHERE size(amts) > 0
    AND ALL(i IN range(1, size(amts)-1) WHERE amts[i-1] < amts[i])
  RETURN DISTINCT s.id AS s, t.id AS t, amts
}
WITH collect({s:s, t:t, amts:amts}) AS orig_seq
CALL {
  // Lifted graph (amount sequence comes from TRANSFER_LIFT edges)
  MATCH (start:Stage {level:-1})
  MATCH p = (start)-[:TRANSFER_LIFT*]->(x:Stage)
  WITH start, x, [r IN relationships(p) | r.amount] AS amts
  RETURN DISTINCT start.accId AS s, x.accId AS t, amts
}
WITH orig_seq, collect({s:s, t:t, amts:amts}) AS lift_seq
WITH
  [row IN orig_seq WHERE NOT row IN lift_seq] AS missing_in_lift,
  [row IN lift_seq WHERE NOT row IN orig_seq] AS extra_in_lift
RETURN
  size(missing_in_lift) AS missing_sequences,
  size(extra_in_lift)   AS extra_sequences,
  (size(missing_in_lift)=0 AND size(extra_in_lift)=0) AS sequences_ok,
  missing_in_lift[0..5] AS sample_missing_sequences,
  extra_in_lift[0..5]   AS sample_extra_sequences;
